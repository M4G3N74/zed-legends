"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./components/context/SimplePlayerContext.js":
/*!***************************************************!*\
  !*** ./components/context/SimplePlayerContext.js ***!
  \***************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerProvider: function() { return /* binding */ PlayerProvider; },\n/* harmony export */   usePlayer: function() { return /* binding */ usePlayer; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LibraryContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LibraryContext */ \"./components/context/LibraryContext.js\");\n\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\nconst PlayerContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)();\nfunction PlayerProvider(param) {\n    let { children } = param;\n    _s();\n    const { songs } = (0,_LibraryContext__WEBPACK_IMPORTED_MODULE_2__.useLibrary)();\n    const [currentSong, setCurrentSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isPlaying, setIsPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [duration, setDuration] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [currentTime, setCurrentTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [volume, setVolume] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(1);\n    const [repeat, setRepeat] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"none\"); // 'none', 'one', 'all'\n    const [shuffle, setShuffle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [smartShuffleEnabled, setSmartShuffleEnabled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [bassBoost, setBassBoost] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [megaBoost, setMegaBoost] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [autoplay, setAutoplay] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const playHistoryRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const skipHistoryRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    // Load player preferences from localStorage\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (true) {\n            const savedPreferences = localStorage.getItem(\"playerPreferences\");\n            if (savedPreferences) {\n                try {\n                    const preferences = JSON.parse(savedPreferences);\n                    if (preferences.volume !== undefined) setVolume(preferences.volume);\n                    if (preferences.shuffle !== undefined) setShuffle(preferences.shuffle);\n                    if (preferences.smartShuffleEnabled !== undefined) setSmartShuffleEnabled(preferences.smartShuffleEnabled);\n                    if (preferences.repeat !== undefined) setRepeat(preferences.repeat);\n                    if (preferences.autoplay !== undefined) setAutoplay(preferences.autoplay);\n                    if (preferences.bassBoost !== undefined) setBassBoost(preferences.bassBoost);\n                    if (preferences.megaBoost !== undefined) setMegaBoost(preferences.megaBoost);\n                } catch (error) {\n                    console.error(\"Error loading player preferences:\", error);\n                }\n            }\n            // Load play history\n            const savedPlayHistory = localStorage.getItem(\"playHistory\");\n            if (savedPlayHistory) {\n                try {\n                    playHistoryRef.current = JSON.parse(savedPlayHistory);\n                } catch (error) {\n                    console.error(\"Error loading play history:\", error);\n                }\n            }\n        }\n    }, []);\n    // Save player preferences to localStorage\n    const savePlayerPreferences = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (true) {\n            const preferences = {\n                volume,\n                shuffle,\n                smartShuffleEnabled,\n                repeat,\n                autoplay,\n                bassBoost,\n                megaBoost\n            };\n            localStorage.setItem(\"playerPreferences\", JSON.stringify(preferences));\n        }\n    }, [\n        volume,\n        shuffle,\n        smartShuffleEnabled,\n        repeat,\n        autoplay,\n        bassBoost,\n        megaBoost\n    ]);\n    // Track user interaction with songs\n    const trackUserInteraction = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((interactionType, songId)=>{\n        if (!songId) return;\n        // Record interaction locally\n        if (interactionType === \"play\") {\n            // Add to play history if not already the last played song\n            const lastPlayed = playHistoryRef.current[playHistoryRef.current.length - 1];\n            if (lastPlayed !== songId) {\n                playHistoryRef.current.push(songId);\n                // Keep history at a reasonable size\n                if (playHistoryRef.current.length > 100) {\n                    playHistoryRef.current = playHistoryRef.current.slice(-100);\n                }\n                // Save to localStorage\n                localStorage.setItem(\"playHistory\", JSON.stringify(playHistoryRef.current));\n            }\n        } else if (interactionType === \"skip\") {\n            skipHistoryRef.current.push(songId);\n            // Keep history at a reasonable size\n            if (skipHistoryRef.current.length > 100) {\n                skipHistoryRef.current = skipHistoryRef.current.slice(-100);\n            }\n            // Save to localStorage\n            localStorage.setItem(\"skipHistory\", JSON.stringify(skipHistoryRef.current));\n        }\n        // Send to backend if smart shuffle is enabled\n        if (smartShuffleEnabled) {\n            try {\n                fetch(\"/api/track-interaction\", {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\"\n                    },\n                    body: JSON.stringify({\n                        userId: localStorage.getItem(\"userId\") || \"anonymous\",\n                        songId,\n                        interactionType,\n                        timestamp: new Date().toISOString()\n                    })\n                }).catch((error)=>{\n                    console.error(\"Failed to send interaction data to backend:\", error);\n                });\n            } catch (error) {\n                console.error(\"Failed to send interaction data to backend:\", error);\n            }\n        }\n    }, [\n        smartShuffleEnabled\n    ]);\n    // Load a song\n    const loadSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((song)=>{\n        if (!song) return;\n        console.log(\"Loading song:\", song.title);\n        // Update current song\n        setCurrentSong(song);\n        // Update audio source\n        if (audioRef.current) {\n            const songPath = \"/music/\".concat(encodeURIComponent(song.file));\n            console.log(\"Song path:\", songPath);\n            audioRef.current.src = songPath;\n            audioRef.current.load();\n            audioRef.current.volume = volume;\n        }\n        // Track this interaction\n        trackUserInteraction(\"play\", song.id);\n    }, [\n        volume,\n        trackUserInteraction\n    ]);\n    // Play the current song\n    const playSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!audioRef.current) return;\n        console.log(\"Playing song\");\n        const playPromise = audioRef.current.play();\n        if (playPromise !== undefined) {\n            playPromise.catch((error)=>{\n                console.error(\"Error playing audio:\", error);\n                if (error.name === \"NotAllowedError\") {\n                    alert(\"Autoplay was blocked. Please click play to start playback.\");\n                }\n            });\n        }\n    }, []);\n    // Pause the current song\n    const pauseSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!audioRef.current) return;\n        console.log(\"Pausing song\");\n        audioRef.current.pause();\n    }, []);\n    // Play next song\n    const playNextSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!currentSong || !songs || songs.length === 0) return;\n        console.log(\"Playing next song\");\n        let nextSongIndex = -1;\n        // Handle different playback modes\n        if (shuffle) {\n            // Regular shuffle - completely random\n            const availableSongs = songs.filter((song)=>song.id !== currentSong.id);\n            if (availableSongs.length === 0) return;\n            const randomIndex = Math.floor(Math.random() * availableSongs.length);\n            loadSong(availableSongs[randomIndex]);\n        } else {\n            // Find current song index\n            const currentIndex = songs.findIndex((song)=>song.id === currentSong.id);\n            if (currentIndex !== -1) {\n                // Get next song index\n                nextSongIndex = currentIndex + 1;\n                // Handle repeat all\n                if (nextSongIndex >= songs.length) {\n                    if (repeat === \"all\") {\n                        nextSongIndex = 0;\n                    } else if (!autoplay) {\n                        // Stop playback if we're at the end and not repeating\n                        return;\n                    } else {\n                        nextSongIndex = 0; // Default to first song if autoplay is on\n                    }\n                }\n                // Load and play next song\n                loadSong(songs[nextSongIndex]);\n            }\n        }\n        // Play the song if autoplay is enabled\n        if (autoplay) playSong();\n    }, [\n        currentSong,\n        songs,\n        shuffle,\n        repeat,\n        autoplay,\n        loadSong,\n        playSong\n    ]);\n    // Play previous song\n    const playPreviousSong = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!currentSong || !songs || songs.length === 0) return;\n        // If current time is more than 3 seconds, restart the current song\n        if (audioRef.current && audioRef.current.currentTime > 3) {\n            audioRef.current.currentTime = 0;\n            return;\n        }\n        // Find current song index\n        const currentIndex = songs.findIndex((song)=>song.id === currentSong.id);\n        if (currentIndex !== -1) {\n            // Get previous song index\n            let prevSongIndex = currentIndex - 1;\n            // Handle wrap around\n            if (prevSongIndex < 0) {\n                if (repeat === \"all\") {\n                    prevSongIndex = songs.length - 1;\n                } else {\n                    // If not repeating, stay on first song\n                    prevSongIndex = 0;\n                }\n            }\n            // Load and play previous song\n            loadSong(songs[prevSongIndex]);\n            if (isPlaying) playSong();\n        }\n    }, [\n        currentSong,\n        songs,\n        repeat,\n        isPlaying,\n        loadSong,\n        playSong\n    ]);\n    // Toggle bass boost (dummy implementation)\n    const toggleBassBoost = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(()=>{\n        if (!bassBoost && !megaBoost) {\n            setBassBoost(true);\n            setMegaBoost(false);\n        } else if (bassBoost && !megaBoost) {\n            setBassBoost(true);\n            setMegaBoost(true);\n        } else {\n            setBassBoost(false);\n            setMegaBoost(false);\n        }\n        savePlayerPreferences();\n    }, [\n        bassBoost,\n        megaBoost,\n        savePlayerPreferences\n    ]);\n    // Set up Media Session API for background playback\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!currentSong || typeof navigator === \"undefined\" || !(\"mediaSession\" in navigator)) return;\n        try {\n            navigator.mediaSession.metadata = new MediaMetadata({\n                title: currentSong.title || \"Unknown Title\",\n                artist: currentSong.artist || \"Unknown Artist\",\n                album: currentSong.album || \"Unknown Album\",\n                artwork: [\n                    {\n                        src: currentSong.albumArt || \"/images/album-art.png\",\n                        sizes: \"512x512\",\n                        type: \"image/png\"\n                    }\n                ]\n            });\n            // Set action handlers for media keys\n            navigator.mediaSession.setActionHandler(\"play\", playSong);\n            navigator.mediaSession.setActionHandler(\"pause\", pauseSong);\n            navigator.mediaSession.setActionHandler(\"previoustrack\", playPreviousSong);\n            navigator.mediaSession.setActionHandler(\"nexttrack\", playNextSong);\n        } catch (error) {\n            console.error(\"Failed to update Media Session metadata:\", error);\n        }\n    }, [\n        currentSong,\n        playSong,\n        pauseSong,\n        playPreviousSong,\n        playNextSong\n    ]);\n    const value = {\n        currentSong,\n        isPlaying,\n        duration,\n        currentTime,\n        volume,\n        repeat,\n        shuffle,\n        smartShuffleEnabled,\n        bassBoost,\n        megaBoost,\n        autoplay,\n        audioRef,\n        loadSong,\n        playSong,\n        pauseSong,\n        playNextSong,\n        playPreviousSong,\n        toggleBassBoost,\n        trackUserInteraction,\n        setVolume: (newVolume)=>{\n            setVolume(newVolume);\n            if (audioRef.current) {\n                audioRef.current.volume = newVolume;\n            }\n            savePlayerPreferences();\n        },\n        setCurrentTime: (time)=>{\n            if (audioRef.current) {\n                audioRef.current.currentTime = time;\n            }\n        },\n        setRepeat: (value)=>{\n            setRepeat(value);\n            savePlayerPreferences();\n        },\n        setShuffle: (value)=>{\n            setShuffle(value);\n            savePlayerPreferences();\n        },\n        setSmartShuffleEnabled: (value)=>{\n            setSmartShuffleEnabled(value);\n            savePlayerPreferences();\n        },\n        setAutoplay: (value)=>{\n            setAutoplay(value);\n            savePlayerPreferences();\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(PlayerContext.Provider, {\n        value: value,\n        children: [\n            children,\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"audio\", {\n                ref: audioRef,\n                preload: \"auto\",\n                playsInline: true,\n                loop: repeat === \"one\",\n                onTimeUpdate: ()=>{\n                    var _audioRef_current;\n                    return setCurrentTime(((_audioRef_current = audioRef.current) === null || _audioRef_current === void 0 ? void 0 : _audioRef_current.currentTime) || 0);\n                },\n                onDurationChange: ()=>{\n                    var _audioRef_current;\n                    return setDuration(((_audioRef_current = audioRef.current) === null || _audioRef_current === void 0 ? void 0 : _audioRef_current.duration) || 0);\n                },\n                onPlay: ()=>setIsPlaying(true),\n                onPause: ()=>setIsPlaying(false),\n                onEnded: ()=>{\n                    if (repeat === \"one\") {\n                        audioRef.current.currentTime = 0;\n                        playSong();\n                    } else {\n                        playNextSong();\n                    }\n                }\n            }, void 0, false, {\n                fileName: \"/home/purple/work/music-stream-next/components/context/SimplePlayerContext.js\",\n                lineNumber: 349,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/purple/work/music-stream-next/components/context/SimplePlayerContext.js\",\n        lineNumber: 347,\n        columnNumber: 5\n    }, this);\n}\n_s(PlayerProvider, \"Lp5ruPNKjpC0zsTratpX6wQ6X+U=\", false, function() {\n    return [\n        _LibraryContext__WEBPACK_IMPORTED_MODULE_2__.useLibrary\n    ];\n});\n_c = PlayerProvider;\nfunction usePlayer() {\n    _s1();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(PlayerContext);\n}\n_s1(usePlayer, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nvar _c;\n$RefreshReg$(_c, \"PlayerProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9jb21wb25lbnRzL2NvbnRleHQvU2ltcGxlUGxheWVyQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBNEY7QUFDOUM7QUFFOUMsTUFBTU8sOEJBQWdCUCxvREFBYUE7QUFFNUIsU0FBU1EsZUFBZSxLQUFZO1FBQVosRUFBRUMsUUFBUSxFQUFFLEdBQVo7O0lBQzdCLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUdKLDJEQUFVQTtJQUM1QixNQUFNLENBQUNLLGFBQWFDLGVBQWUsR0FBR1YsK0NBQVFBLENBQUM7SUFDL0MsTUFBTSxDQUFDVyxXQUFXQyxhQUFhLEdBQUdaLCtDQUFRQSxDQUFDO0lBQzNDLE1BQU0sQ0FBQ2EsVUFBVUMsWUFBWSxHQUFHZCwrQ0FBUUEsQ0FBQztJQUN6QyxNQUFNLENBQUNlLGFBQWFDLGVBQWUsR0FBR2hCLCtDQUFRQSxDQUFDO0lBQy9DLE1BQU0sQ0FBQ2lCLFFBQVFDLFVBQVUsR0FBR2xCLCtDQUFRQSxDQUFDO0lBQ3JDLE1BQU0sQ0FBQ21CLFFBQVFDLFVBQVUsR0FBR3BCLCtDQUFRQSxDQUFDLFNBQVMsdUJBQXVCO0lBQ3JFLE1BQU0sQ0FBQ3FCLFNBQVNDLFdBQVcsR0FBR3RCLCtDQUFRQSxDQUFDO0lBQ3ZDLE1BQU0sQ0FBQ3VCLHFCQUFxQkMsdUJBQXVCLEdBQUd4QiwrQ0FBUUEsQ0FBQztJQUMvRCxNQUFNLENBQUN5QixXQUFXQyxhQUFhLEdBQUcxQiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUMyQixXQUFXQyxhQUFhLEdBQUc1QiwrQ0FBUUEsQ0FBQztJQUMzQyxNQUFNLENBQUM2QixVQUFVQyxZQUFZLEdBQUc5QiwrQ0FBUUEsQ0FBQztJQUV6QyxNQUFNK0IsV0FBVzVCLDZDQUFNQSxDQUFDO0lBQ3hCLE1BQU02QixpQkFBaUI3Qiw2Q0FBTUEsQ0FBQyxFQUFFO0lBQ2hDLE1BQU04QixpQkFBaUI5Qiw2Q0FBTUEsQ0FBQyxFQUFFO0lBRWhDLDRDQUE0QztJQUM1Q0YsZ0RBQVNBLENBQUM7UUFD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aUIsRUFBQUEsb0JBQUFBLFNBQVNhLE9BQU8sY0FBaEJiLHdDQUFBQSxrQkFBa0JsQixRQUFRLEtBQUk7O2dCQUNsRXVHLFFBQVEsSUFBTXhHLGFBQWE7Z0JBQzNCeUcsU0FBUyxJQUFNekcsYUFBYTtnQkFDNUIwRyxTQUFTO29CQUNQLElBQUluRyxXQUFXLE9BQU87d0JBQ3BCWSxTQUFTYSxPQUFPLENBQUM3QixXQUFXLEdBQUc7d0JBQy9CMkQ7b0JBQ0YsT0FBTzt3QkFDTE87b0JBQ0Y7Z0JBQ0Y7Ozs7Ozs7Ozs7OztBQUlSO0dBM1dnQjNFOztRQUNJRix1REFBVUE7OztLQURkRTtBQTZXVCxTQUFTaUg7O0lBQ2QsT0FBT3hILGlEQUFVQSxDQUFDTTtBQUNwQjtJQUZnQmtIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY29udGV4dC9TaW1wbGVQbGF5ZXJDb250ZXh0LmpzP2FhN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUxpYnJhcnkgfSBmcm9tICcuL0xpYnJhcnlDb250ZXh0JztcblxuY29uc3QgUGxheWVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIFBsYXllclByb3ZpZGVyKHsgY2hpbGRyZW4gfSkge1xuICBjb25zdCB7IHNvbmdzIH0gPSB1c2VMaWJyYXJ5KCk7XG4gIGNvbnN0IFtjdXJyZW50U29uZywgc2V0Q3VycmVudFNvbmddID0gdXNlU3RhdGUobnVsbCk7XG4gIGNvbnN0IFtpc1BsYXlpbmcsIHNldElzUGxheWluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtkdXJhdGlvbiwgc2V0RHVyYXRpb25dID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtjdXJyZW50VGltZSwgc2V0Q3VycmVudFRpbWVdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFt2b2x1bWUsIHNldFZvbHVtZV0gPSB1c2VTdGF0ZSgxKTtcbiAgY29uc3QgW3JlcGVhdCwgc2V0UmVwZWF0XSA9IHVzZVN0YXRlKCdub25lJyk7IC8vICdub25lJywgJ29uZScsICdhbGwnXG4gIGNvbnN0IFtzaHVmZmxlLCBzZXRTaHVmZmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3NtYXJ0U2h1ZmZsZUVuYWJsZWQsIHNldFNtYXJ0U2h1ZmZsZUVuYWJsZWRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFtiYXNzQm9vc3QsIHNldEJhc3NCb29zdF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFttZWdhQm9vc3QsIHNldE1lZ2FCb29zdF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFthdXRvcGxheSwgc2V0QXV0b3BsYXldID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgY29uc3QgYXVkaW9SZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBsYXlIaXN0b3J5UmVmID0gdXNlUmVmKFtdKTtcbiAgY29uc3Qgc2tpcEhpc3RvcnlSZWYgPSB1c2VSZWYoW10pO1xuXG4gIC8vIExvYWQgcGxheWVyIHByZWZlcmVuY2VzIGZyb20gbG9jYWxTdG9yYWdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBzYXZlZFByZWZlcmVuY2VzID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BsYXllclByZWZlcmVuY2VzJyk7XG4gICAgICBpZiAoc2F2ZWRQcmVmZXJlbmNlcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHByZWZlcmVuY2VzID0gSlNPTi5wYXJzZShzYXZlZFByZWZlcmVuY2VzKTtcblxuICAgICAgICAgIGlmIChwcmVmZXJlbmNlcy52b2x1bWUgIT09IHVuZGVmaW5lZCkgc2V0Vm9sdW1lKHByZWZlcmVuY2VzLnZvbHVtZSk7XG4gICAgICAgICAgaWYgKHByZWZlcmVuY2VzLnNodWZmbGUgIT09IHVuZGVmaW5lZCkgc2V0U2h1ZmZsZShwcmVmZXJlbmNlcy5zaHVmZmxlKTtcbiAgICAgICAgICBpZiAocHJlZmVyZW5jZXMuc21hcnRTaHVmZmxlRW5hYmxlZCAhPT0gdW5kZWZpbmVkKSBzZXRTbWFydFNodWZmbGVFbmFibGVkKHByZWZlcmVuY2VzLnNtYXJ0U2h1ZmZsZUVuYWJsZWQpO1xuICAgICAgICAgIGlmIChwcmVmZXJlbmNlcy5yZXBlYXQgIT09IHVuZGVmaW5lZCkgc2V0UmVwZWF0KHByZWZlcmVuY2VzLnJlcGVhdCk7XG4gICAgICAgICAgaWYgKHByZWZlcmVuY2VzLmF1dG9wbGF5ICE9PSB1bmRlZmluZWQpIHNldEF1dG9wbGF5KHByZWZlcmVuY2VzLmF1dG9wbGF5KTtcbiAgICAgICAgICBpZiAocHJlZmVyZW5jZXMuYmFzc0Jvb3N0ICE9PSB1bmRlZmluZWQpIHNldEJhc3NCb29zdChwcmVmZXJlbmNlcy5iYXNzQm9vc3QpO1xuICAgICAgICAgIGlmIChwcmVmZXJlbmNlcy5tZWdhQm9vc3QgIT09IHVuZGVmaW5lZCkgc2V0TWVnYUJvb3N0KHByZWZlcmVuY2VzLm1lZ2FCb29zdCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBwbGF5ZXIgcHJlZmVyZW5jZXM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgcGxheSBoaXN0b3J5XG4gICAgICBjb25zdCBzYXZlZFBsYXlIaXN0b3J5ID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3BsYXlIaXN0b3J5Jyk7XG4gICAgICBpZiAoc2F2ZWRQbGF5SGlzdG9yeSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHBsYXlIaXN0b3J5UmVmLmN1cnJlbnQgPSBKU09OLnBhcnNlKHNhdmVkUGxheUhpc3RvcnkpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgcGxheSBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFNhdmUgcGxheWVyIHByZWZlcmVuY2VzIHRvIGxvY2FsU3RvcmFnZVxuICBjb25zdCBzYXZlUGxheWVyUHJlZmVyZW5jZXMgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCBwcmVmZXJlbmNlcyA9IHtcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBzaHVmZmxlLFxuICAgICAgICBzbWFydFNodWZmbGVFbmFibGVkLFxuICAgICAgICByZXBlYXQsXG4gICAgICAgIGF1dG9wbGF5LFxuICAgICAgICBiYXNzQm9vc3QsXG4gICAgICAgIG1lZ2FCb29zdFxuICAgICAgfTtcblxuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BsYXllclByZWZlcmVuY2VzJywgSlNPTi5zdHJpbmdpZnkocHJlZmVyZW5jZXMpKTtcbiAgICB9XG4gIH0sIFt2b2x1bWUsIHNodWZmbGUsIHNtYXJ0U2h1ZmZsZUVuYWJsZWQsIHJlcGVhdCwgYXV0b3BsYXksIGJhc3NCb29zdCwgbWVnYUJvb3N0XSk7XG5cbiAgLy8gVHJhY2sgdXNlciBpbnRlcmFjdGlvbiB3aXRoIHNvbmdzXG4gIGNvbnN0IHRyYWNrVXNlckludGVyYWN0aW9uID0gdXNlQ2FsbGJhY2soKGludGVyYWN0aW9uVHlwZSwgc29uZ0lkKSA9PiB7XG4gICAgaWYgKCFzb25nSWQpIHJldHVybjtcblxuICAgIC8vIFJlY29yZCBpbnRlcmFjdGlvbiBsb2NhbGx5XG4gICAgaWYgKGludGVyYWN0aW9uVHlwZSA9PT0gJ3BsYXknKSB7XG4gICAgICAvLyBBZGQgdG8gcGxheSBoaXN0b3J5IGlmIG5vdCBhbHJlYWR5IHRoZSBsYXN0IHBsYXllZCBzb25nXG4gICAgICBjb25zdCBsYXN0UGxheWVkID0gcGxheUhpc3RvcnlSZWYuY3VycmVudFtwbGF5SGlzdG9yeVJlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RQbGF5ZWQgIT09IHNvbmdJZCkge1xuICAgICAgICBwbGF5SGlzdG9yeVJlZi5jdXJyZW50LnB1c2goc29uZ0lkKTtcbiAgICAgICAgLy8gS2VlcCBoaXN0b3J5IGF0IGEgcmVhc29uYWJsZSBzaXplXG4gICAgICAgIGlmIChwbGF5SGlzdG9yeVJlZi5jdXJyZW50Lmxlbmd0aCA+IDEwMCkge1xuICAgICAgICAgIHBsYXlIaXN0b3J5UmVmLmN1cnJlbnQgPSBwbGF5SGlzdG9yeVJlZi5jdXJyZW50LnNsaWNlKC0xMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2F2ZSB0byBsb2NhbFN0b3JhZ2VcbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3BsYXlIaXN0b3J5JywgSlNPTi5zdHJpbmdpZnkocGxheUhpc3RvcnlSZWYuY3VycmVudCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW50ZXJhY3Rpb25UeXBlID09PSAnc2tpcCcpIHtcbiAgICAgIHNraXBIaXN0b3J5UmVmLmN1cnJlbnQucHVzaChzb25nSWQpO1xuICAgICAgLy8gS2VlcCBoaXN0b3J5IGF0IGEgcmVhc29uYWJsZSBzaXplXG4gICAgICBpZiAoc2tpcEhpc3RvcnlSZWYuY3VycmVudC5sZW5ndGggPiAxMDApIHtcbiAgICAgICAgc2tpcEhpc3RvcnlSZWYuY3VycmVudCA9IHNraXBIaXN0b3J5UmVmLmN1cnJlbnQuc2xpY2UoLTEwMCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhdmUgdG8gbG9jYWxTdG9yYWdlXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2tpcEhpc3RvcnknLCBKU09OLnN0cmluZ2lmeShza2lwSGlzdG9yeVJlZi5jdXJyZW50KSk7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0byBiYWNrZW5kIGlmIHNtYXJ0IHNodWZmbGUgaXMgZW5hYmxlZFxuICAgIGlmIChzbWFydFNodWZmbGVFbmFibGVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmZXRjaCgnL2FwaS90cmFjay1pbnRlcmFjdGlvbicsIHtcbiAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICB1c2VySWQ6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VySWQnKSB8fCAnYW5vbnltb3VzJyxcbiAgICAgICAgICAgIHNvbmdJZCxcbiAgICAgICAgICAgIGludGVyYWN0aW9uVHlwZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCBpbnRlcmFjdGlvbiBkYXRhIHRvIGJhY2tlbmQ6JywgZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZW5kIGludGVyYWN0aW9uIGRhdGEgdG8gYmFja2VuZDonLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCBbc21hcnRTaHVmZmxlRW5hYmxlZF0pO1xuXG4gIC8vIExvYWQgYSBzb25nXG4gIGNvbnN0IGxvYWRTb25nID0gdXNlQ2FsbGJhY2soKHNvbmcpID0+IHtcbiAgICBpZiAoIXNvbmcpIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKCdMb2FkaW5nIHNvbmc6Jywgc29uZy50aXRsZSk7XG5cbiAgICAvLyBVcGRhdGUgY3VycmVudCBzb25nXG4gICAgc2V0Q3VycmVudFNvbmcoc29uZyk7XG5cbiAgICAvLyBVcGRhdGUgYXVkaW8gc291cmNlXG4gICAgaWYgKGF1ZGlvUmVmLmN1cnJlbnQpIHtcbiAgICAgIGNvbnN0IHNvbmdQYXRoID0gYC9tdXNpYy8ke2VuY29kZVVSSUNvbXBvbmVudChzb25nLmZpbGUpfWA7XG4gICAgICBjb25zb2xlLmxvZygnU29uZyBwYXRoOicsIHNvbmdQYXRoKTtcblxuICAgICAgYXVkaW9SZWYuY3VycmVudC5zcmMgPSBzb25nUGF0aDtcbiAgICAgIGF1ZGlvUmVmLmN1cnJlbnQubG9hZCgpO1xuICAgICAgYXVkaW9SZWYuY3VycmVudC52b2x1bWUgPSB2b2x1bWU7XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhpcyBpbnRlcmFjdGlvblxuICAgIHRyYWNrVXNlckludGVyYWN0aW9uKCdwbGF5Jywgc29uZy5pZCk7XG4gIH0sIFt2b2x1bWUsIHRyYWNrVXNlckludGVyYWN0aW9uXSk7XG5cbiAgLy8gUGxheSB0aGUgY3VycmVudCBzb25nXG4gIGNvbnN0IHBsYXlTb25nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghYXVkaW9SZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc29sZS5sb2coJ1BsYXlpbmcgc29uZycpO1xuXG4gICAgY29uc3QgcGxheVByb21pc2UgPSBhdWRpb1JlZi5jdXJyZW50LnBsYXkoKTtcblxuICAgIGlmIChwbGF5UHJvbWlzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwbGF5UHJvbWlzZS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBsYXlpbmcgYXVkaW86JywgZXJyb3IpO1xuXG4gICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgIGFsZXJ0KCdBdXRvcGxheSB3YXMgYmxvY2tlZC4gUGxlYXNlIGNsaWNrIHBsYXkgdG8gc3RhcnQgcGxheWJhY2suJyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW10pO1xuXG4gIC8vIFBhdXNlIHRoZSBjdXJyZW50IHNvbmdcbiAgY29uc3QgcGF1c2VTb25nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghYXVkaW9SZWYuY3VycmVudCkgcmV0dXJuO1xuXG4gICAgY29uc29sZS5sb2coJ1BhdXNpbmcgc29uZycpO1xuICAgIGF1ZGlvUmVmLmN1cnJlbnQucGF1c2UoKTtcbiAgfSwgW10pO1xuXG4gIC8vIFBsYXkgbmV4dCBzb25nXG4gIGNvbnN0IHBsYXlOZXh0U29uZyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWN1cnJlbnRTb25nIHx8ICFzb25ncyB8fCBzb25ncy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgIGNvbnNvbGUubG9nKCdQbGF5aW5nIG5leHQgc29uZycpO1xuXG4gICAgbGV0IG5leHRTb25nSW5kZXggPSAtMTtcblxuICAgIC8vIEhhbmRsZSBkaWZmZXJlbnQgcGxheWJhY2sgbW9kZXNcbiAgICBpZiAoc2h1ZmZsZSkge1xuICAgICAgLy8gUmVndWxhciBzaHVmZmxlIC0gY29tcGxldGVseSByYW5kb21cbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNvbmdzID0gc29uZ3MuZmlsdGVyKHNvbmcgPT4gc29uZy5pZCAhPT0gY3VycmVudFNvbmcuaWQpO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXZhaWxhYmxlU29uZ3MubGVuZ3RoKTtcbiAgICAgIGxvYWRTb25nKGF2YWlsYWJsZVNvbmdzW3JhbmRvbUluZGV4XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgY3VycmVudCBzb25nIGluZGV4XG4gICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBzb25ncy5maW5kSW5kZXgoc29uZyA9PiBzb25nLmlkID09PSBjdXJyZW50U29uZy5pZCk7XG5cbiAgICAgIGlmIChjdXJyZW50SW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIEdldCBuZXh0IHNvbmcgaW5kZXhcbiAgICAgICAgbmV4dFNvbmdJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG5cbiAgICAgICAgLy8gSGFuZGxlIHJlcGVhdCBhbGxcbiAgICAgICAgaWYgKG5leHRTb25nSW5kZXggPj0gc29uZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHJlcGVhdCA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgIG5leHRTb25nSW5kZXggPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIWF1dG9wbGF5KSB7XG4gICAgICAgICAgICAvLyBTdG9wIHBsYXliYWNrIGlmIHdlJ3JlIGF0IHRoZSBlbmQgYW5kIG5vdCByZXBlYXRpbmdcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV4dFNvbmdJbmRleCA9IDA7IC8vIERlZmF1bHQgdG8gZmlyc3Qgc29uZyBpZiBhdXRvcGxheSBpcyBvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExvYWQgYW5kIHBsYXkgbmV4dCBzb25nXG4gICAgICAgIGxvYWRTb25nKHNvbmdzW25leHRTb25nSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQbGF5IHRoZSBzb25nIGlmIGF1dG9wbGF5IGlzIGVuYWJsZWRcbiAgICBpZiAoYXV0b3BsYXkpIHBsYXlTb25nKCk7XG4gIH0sIFtjdXJyZW50U29uZywgc29uZ3MsIHNodWZmbGUsIHJlcGVhdCwgYXV0b3BsYXksIGxvYWRTb25nLCBwbGF5U29uZ10pO1xuXG4gIC8vIFBsYXkgcHJldmlvdXMgc29uZ1xuICBjb25zdCBwbGF5UHJldmlvdXNTb25nID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmICghY3VycmVudFNvbmcgfHwgIXNvbmdzIHx8IHNvbmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgLy8gSWYgY3VycmVudCB0aW1lIGlzIG1vcmUgdGhhbiAzIHNlY29uZHMsIHJlc3RhcnQgdGhlIGN1cnJlbnQgc29uZ1xuICAgIGlmIChhdWRpb1JlZi5jdXJyZW50ICYmIGF1ZGlvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPiAzKSB7XG4gICAgICBhdWRpb1JlZi5jdXJyZW50LmN1cnJlbnRUaW1lID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGN1cnJlbnQgc29uZyBpbmRleFxuICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IHNvbmdzLmZpbmRJbmRleChzb25nID0+IHNvbmcuaWQgPT09IGN1cnJlbnRTb25nLmlkKTtcblxuICAgIGlmIChjdXJyZW50SW5kZXggIT09IC0xKSB7XG4gICAgICAvLyBHZXQgcHJldmlvdXMgc29uZyBpbmRleFxuICAgICAgbGV0IHByZXZTb25nSW5kZXggPSBjdXJyZW50SW5kZXggLSAxO1xuXG4gICAgICAvLyBIYW5kbGUgd3JhcCBhcm91bmRcbiAgICAgIGlmIChwcmV2U29uZ0luZGV4IDwgMCkge1xuICAgICAgICBpZiAocmVwZWF0ID09PSAnYWxsJykge1xuICAgICAgICAgIHByZXZTb25nSW5kZXggPSBzb25ncy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vdCByZXBlYXRpbmcsIHN0YXkgb24gZmlyc3Qgc29uZ1xuICAgICAgICAgIHByZXZTb25nSW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgYW5kIHBsYXkgcHJldmlvdXMgc29uZ1xuICAgICAgbG9hZFNvbmcoc29uZ3NbcHJldlNvbmdJbmRleF0pO1xuICAgICAgaWYgKGlzUGxheWluZykgcGxheVNvbmcoKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50U29uZywgc29uZ3MsIHJlcGVhdCwgaXNQbGF5aW5nLCBsb2FkU29uZywgcGxheVNvbmddKTtcblxuICAvLyBUb2dnbGUgYmFzcyBib29zdCAoZHVtbXkgaW1wbGVtZW50YXRpb24pXG4gIGNvbnN0IHRvZ2dsZUJhc3NCb29zdCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAoIWJhc3NCb29zdCAmJiAhbWVnYUJvb3N0KSB7XG4gICAgICBzZXRCYXNzQm9vc3QodHJ1ZSk7XG4gICAgICBzZXRNZWdhQm9vc3QoZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoYmFzc0Jvb3N0ICYmICFtZWdhQm9vc3QpIHtcbiAgICAgIHNldEJhc3NCb29zdCh0cnVlKTtcbiAgICAgIHNldE1lZ2FCb29zdCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0QmFzc0Jvb3N0KGZhbHNlKTtcbiAgICAgIHNldE1lZ2FCb29zdChmYWxzZSk7XG4gICAgfVxuXG4gICAgc2F2ZVBsYXllclByZWZlcmVuY2VzKCk7XG4gIH0sIFtiYXNzQm9vc3QsIG1lZ2FCb29zdCwgc2F2ZVBsYXllclByZWZlcmVuY2VzXSk7XG5cbiAgLy8gU2V0IHVwIE1lZGlhIFNlc3Npb24gQVBJIGZvciBiYWNrZ3JvdW5kIHBsYXliYWNrXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjdXJyZW50U29uZyB8fCB0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJyB8fCAhKCdtZWRpYVNlc3Npb24nIGluIG5hdmlnYXRvcikpIHJldHVybjtcblxuICAgIHRyeSB7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFTZXNzaW9uLm1ldGFkYXRhID0gbmV3IE1lZGlhTWV0YWRhdGEoe1xuICAgICAgICB0aXRsZTogY3VycmVudFNvbmcudGl0bGUgfHwgJ1Vua25vd24gVGl0bGUnLFxuICAgICAgICBhcnRpc3Q6IGN1cnJlbnRTb25nLmFydGlzdCB8fCAnVW5rbm93biBBcnRpc3QnLFxuICAgICAgICBhbGJ1bTogY3VycmVudFNvbmcuYWxidW0gfHwgJ1Vua25vd24gQWxidW0nLFxuICAgICAgICBhcnR3b3JrOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3JjOiBjdXJyZW50U29uZy5hbGJ1bUFydCB8fCAnL2ltYWdlcy9hbGJ1bS1hcnQucG5nJyxcbiAgICAgICAgICAgIHNpemVzOiAnNTEyeDUxMicsXG4gICAgICAgICAgICB0eXBlOiAnaW1hZ2UvcG5nJ1xuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSk7XG5cbiAgICAgIC8vIFNldCBhY3Rpb24gaGFuZGxlcnMgZm9yIG1lZGlhIGtleXNcbiAgICAgIG5hdmlnYXRvci5tZWRpYVNlc3Npb24uc2V0QWN0aW9uSGFuZGxlcigncGxheScsIHBsYXlTb25nKTtcbiAgICAgIG5hdmlnYXRvci5tZWRpYVNlc3Npb24uc2V0QWN0aW9uSGFuZGxlcigncGF1c2UnLCBwYXVzZVNvbmcpO1xuICAgICAgbmF2aWdhdG9yLm1lZGlhU2Vzc2lvbi5zZXRBY3Rpb25IYW5kbGVyKCdwcmV2aW91c3RyYWNrJywgcGxheVByZXZpb3VzU29uZyk7XG4gICAgICBuYXZpZ2F0b3IubWVkaWFTZXNzaW9uLnNldEFjdGlvbkhhbmRsZXIoJ25leHR0cmFjaycsIHBsYXlOZXh0U29uZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byB1cGRhdGUgTWVkaWEgU2Vzc2lvbiBtZXRhZGF0YTonLCBlcnJvcik7XG4gICAgfVxuICB9LCBbY3VycmVudFNvbmcsIHBsYXlTb25nLCBwYXVzZVNvbmcsIHBsYXlQcmV2aW91c1NvbmcsIHBsYXlOZXh0U29uZ10pO1xuXG4gIGNvbnN0IHZhbHVlID0ge1xuICAgIGN1cnJlbnRTb25nLFxuICAgIGlzUGxheWluZyxcbiAgICBkdXJhdGlvbixcbiAgICBjdXJyZW50VGltZSxcbiAgICB2b2x1bWUsXG4gICAgcmVwZWF0LFxuICAgIHNodWZmbGUsXG4gICAgc21hcnRTaHVmZmxlRW5hYmxlZCxcbiAgICBiYXNzQm9vc3QsXG4gICAgbWVnYUJvb3N0LFxuICAgIGF1dG9wbGF5LFxuICAgIGF1ZGlvUmVmLFxuICAgIGxvYWRTb25nLFxuICAgIHBsYXlTb25nLFxuICAgIHBhdXNlU29uZyxcbiAgICBwbGF5TmV4dFNvbmcsXG4gICAgcGxheVByZXZpb3VzU29uZyxcbiAgICB0b2dnbGVCYXNzQm9vc3QsXG4gICAgdHJhY2tVc2VySW50ZXJhY3Rpb24sXG4gICAgc2V0Vm9sdW1lOiAobmV3Vm9sdW1lKSA9PiB7XG4gICAgICBzZXRWb2x1bWUobmV3Vm9sdW1lKTtcbiAgICAgIGlmIChhdWRpb1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGF1ZGlvUmVmLmN1cnJlbnQudm9sdW1lID0gbmV3Vm9sdW1lO1xuICAgICAgfVxuICAgICAgc2F2ZVBsYXllclByZWZlcmVuY2VzKCk7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50VGltZTogKHRpbWUpID0+IHtcbiAgICAgIGlmIChhdWRpb1JlZi5jdXJyZW50KSB7XG4gICAgICAgIGF1ZGlvUmVmLmN1cnJlbnQuY3VycmVudFRpbWUgPSB0aW1lO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0UmVwZWF0OiAodmFsdWUpID0+IHtcbiAgICAgIHNldFJlcGVhdCh2YWx1ZSk7XG4gICAgICBzYXZlUGxheWVyUHJlZmVyZW5jZXMoKTtcbiAgICB9LFxuICAgIHNldFNodWZmbGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgc2V0U2h1ZmZsZSh2YWx1ZSk7XG4gICAgICBzYXZlUGxheWVyUHJlZmVyZW5jZXMoKTtcbiAgICB9LFxuICAgIHNldFNtYXJ0U2h1ZmZsZUVuYWJsZWQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgc2V0U21hcnRTaHVmZmxlRW5hYmxlZCh2YWx1ZSk7XG4gICAgICBzYXZlUGxheWVyUHJlZmVyZW5jZXMoKTtcbiAgICB9LFxuICAgIHNldEF1dG9wbGF5OiAodmFsdWUpID0+IHtcbiAgICAgIHNldEF1dG9wbGF5KHZhbHVlKTtcbiAgICAgIHNhdmVQbGF5ZXJQcmVmZXJlbmNlcygpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKFxuICAgIDxQbGF5ZXJDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgICA8YXVkaW9cbiAgICAgICAgcmVmPXthdWRpb1JlZn1cbiAgICAgICAgcHJlbG9hZD1cImF1dG9cIlxuICAgICAgICBwbGF5c0lubGluZVxuICAgICAgICBsb29wPXtyZXBlYXQgPT09ICdvbmUnfVxuICAgICAgICBvblRpbWVVcGRhdGU9eygpID0+IHNldEN1cnJlbnRUaW1lKGF1ZGlvUmVmLmN1cnJlbnQ/LmN1cnJlbnRUaW1lIHx8IDApfVxuICAgICAgICBvbkR1cmF0aW9uQ2hhbmdlPXsoKSA9PiBzZXREdXJhdGlvbihhdWRpb1JlZi5jdXJyZW50Py5kdXJhdGlvbiB8fCAwKX1cbiAgICAgICAgb25QbGF5PXsoKSA9PiBzZXRJc1BsYXlpbmcodHJ1ZSl9XG4gICAgICAgIG9uUGF1c2U9eygpID0+IHNldElzUGxheWluZyhmYWxzZSl9XG4gICAgICAgIG9uRW5kZWQ9eygpID0+IHtcbiAgICAgICAgICBpZiAocmVwZWF0ID09PSAnb25lJykge1xuICAgICAgICAgICAgYXVkaW9SZWYuY3VycmVudC5jdXJyZW50VGltZSA9IDA7XG4gICAgICAgICAgICBwbGF5U29uZygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwbGF5TmV4dFNvbmcoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH19XG4gICAgICAvPlxuICAgIDwvUGxheWVyQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBsYXllcigpIHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoUGxheWVyQ29udGV4dCk7XG59XG4iXSwibmFtZXMiOlsiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwidXNlTGlicmFyeSIsIlBsYXllckNvbnRleHQiLCJQbGF5ZXJQcm92aWRlciIsImNoaWxkcmVuIiwic29uZ3MiLCJjdXJyZW50U29uZyIsInNldEN1cnJlbnRTb25nIiwiaXNQbGF5aW5nIiwic2V0SXNQbGF5aW5nIiwiZHVyYXRpb24iLCJzZXREdXJhdGlvbiIsImN1cnJlbnRUaW1lIiwic2V0Q3VycmVudFRpbWUiLCJ2b2x1bWUiLCJzZXRWb2x1bWUiLCJyZXBlYXQiLCJzZXRSZXBlYXQiLCJzaHVmZmxlIiwic2V0U2h1ZmZsZSIsInNtYXJ0U2h1ZmZsZUVuYWJsZWQiLCJzZXRTbWFydFNodWZmbGVFbmFibGVkIiwiYmFzc0Jvb3N0Iiwic2V0QmFzc0Jvb3N0IiwibWVnYUJvb3N0Iiwic2V0TWVnYUJvb3N0IiwiYXV0b3BsYXkiLCJzZXRBdXRvcGxheSIsImF1ZGlvUmVmIiwicGxheUhpc3RvcnlSZWYiLCJza2lwSGlzdG9yeVJlZiIsInNhdmVkUHJlZmVyZW5jZXMiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwicHJlZmVyZW5jZXMiLCJKU09OIiwicGFyc2UiLCJ1bmRlZmluZWQiLCJlcnJvciIsImNvbnNvbGUiLCJzYXZlZFBsYXlIaXN0b3J5IiwiY3VycmVudCIsInNhdmVQbGF5ZXJQcmVmZXJlbmNlcyIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJ0cmFja1VzZXJJbnRlcmFjdGlvbiIsImludGVyYWN0aW9uVHlwZSIsInNvbmdJZCIsImxhc3RQbGF5ZWQiLCJsZW5ndGgiLCJwdXNoIiwic2xpY2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwidXNlcklkIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY2F0Y2giLCJsb2FkU29uZyIsInNvbmciLCJsb2ciLCJ0aXRsZSIsInNvbmdQYXRoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZmlsZSIsInNyYyIsImxvYWQiLCJpZCIsInBsYXlTb25nIiwicGxheVByb21pc2UiLCJwbGF5IiwibmFtZSIsImFsZXJ0IiwicGF1c2VTb25nIiwicGF1c2UiLCJwbGF5TmV4dFNvbmciLCJuZXh0U29uZ0luZGV4IiwiYXZhaWxhYmxlU29uZ3MiLCJmaWx0ZXIiLCJyYW5kb21JbmRleCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImN1cnJlbnRJbmRleCIsImZpbmRJbmRleCIsInBsYXlQcmV2aW91c1NvbmciLCJwcmV2U29uZ0luZGV4IiwidG9nZ2xlQmFzc0Jvb3N0IiwibmF2aWdhdG9yIiwibWVkaWFTZXNzaW9uIiwibWV0YWRhdGEiLCJNZWRpYU1ldGFkYXRhIiwiYXJ0aXN0IiwiYWxidW0iLCJhcnR3b3JrIiwiYWxidW1BcnQiLCJzaXplcyIsInR5cGUiLCJzZXRBY3Rpb25IYW5kbGVyIiwidmFsdWUiLCJuZXdWb2x1bWUiLCJ0aW1lIiwiUHJvdmlkZXIiLCJhdWRpbyIsInJlZiIsInByZWxvYWQiLCJwbGF5c0lubGluZSIsImxvb3AiLCJvblRpbWVVcGRhdGUiLCJvbkR1cmF0aW9uQ2hhbmdlIiwib25QbGF5Iiwib25QYXVzZSIsIm9uRW5kZWQiLCJ1c2VQbGF5ZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./components/context/SimplePlayerContext.js\n"));

/***/ })

});